# Prisma 

[prisma-ex-company-ed](./prisma-ex-company-ed/README.md)
[prisma-ex-flightbooking-ed](./prisma-ex-flightbooking-ed/README.md)

---

Prisma is a popular and stable library with an active community contributing to building TypeScriptâ€™s back-end applications. Among the ORMs used in the industry, Prisma happens to be one of the best. It uses regular JavaScript objects and can interact with any SQL database.

```typescript
// create employee
const new_employee = await prisma.employee.create({
  data: {
    employee_name: 'Alice',
    employee_email: 'alice@prisma.io',
  },
})
```

## Features of Prisma
### Models

Prisma has a very unique structure. It provides a model that enables a well-outlined structure, defining how our database columns interact with each other.

```typescript
//schema.prisma

datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"  
}

model Employee {

  id Int @default(autoincrement()) @id
  email String  @unique
  name  String?
}

```

#### There are two major, supported field types:

- [x] Scalar: Scalar data types are the regular data types (for example, String and Int.)
- [x] Model: A field can have a model as a field type, and this is used to define relationships.

A key part of the Prisma schema is the model. The model maps to the table created in the database, similarly to how we defined Employee above. The parts of this model are called fields.

The Prisma schema also introduces attributes. These attributes map the column value to the native database data type. A few of these are:

- [x] @unique: Used to declare a column value as unique.
- [x] @default: Used to set a default value for the column.
- [x] @VarChar(x): Used to declare a character length for the column with x representing the character length.
- [x] @id: Sets the column as the primary id column for that given model or table.

### API Interface

Another important feature is the **Prisma client, which provides an interface for communicating with the database and carrying out queries.**

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// create employee
const new_employee = await prisma.employee.create({
  data: {
    employee_name: 'Alice',
    employee_email: 'alice@prisma.io',
  },
})

// fetch-query:::get all employees 
const employees = await prisma.employee.findMany()
```

Among other TypeScript ORMs, Prisma has a unique feature that automatically writes migration and generates type-safe code. Prisma currently supports MongoDB (preview), SQL Server, MySQL, PostgreSQL, and SQLite.

---

`Good Question`
If a connection error occurs due to the Prisma client not being able to interface with the database (for example, while performing write operation), which of the following might be a cause?
`Answer`
- [x] Database permissions were not granted.
- [x] The schema structure does not match the database tables.
- [x] The table data thatâ€™s been queried may not exist.

## Prisma Setup

```bash
mkdir educative-prisma && cd educative-prisma \
pnpm init -y \
git init \
pnpm add typescript ts-node @types/node express @types/express
touch tsconfig.json
```

```json
 {
   "compilerOptions": {
      "strict": true,
      "sourceMap": true,
      "outDir": "dist",
      "esModuleInterop": true,
      "lib": ["esnext"]
      }
 }
```

```bash
pnpm add prisma --dev \
touch docker-compose.yml
```

```yaml
version: '3.8'
services:
  postgres:
    image: postgres
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=company_db
    ports:
      - '5432:5432'
    expose:
      - 5432
volumes:
  postgres:
```

```bash
docker-compose up -d
```

```bash
pnpm prisma init
```

In the file schema.prisma, weâ€™ll define our model that will be used to generate queries used to create the SQL tables. Letâ€™s create a simple employee model:

```typescript
//schema.prisma

datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"  
}

model employee {

  id Int @default(autoincrement()) @id
  email String  @unique
  name  String?

}
```

```bash
touch .env .gitignore
```

Add the code below to the .env file:

```bash
DATABASE_URL=postgresql://postgres:password@localhost:5432/company_db?schema=public
```

Add the code below to the .gitignore file:

```md
.env

node_modules/ 
```

â€‹â€‹Next, we run a migration to generate the corresponding SQL tables using the following command:

```bash
pnpm prisma migrate dev --name "initial" --preview-feature
```

This command creates a prisma/migrations folder and a migration.sql file in it where we should be able to view the SQL queries generated by Prisma from our model.

The file content should be similar to the one below:


```sql
-- CreateTable
CREATE TABLE "employee" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "employee_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "employee_email_key" ON "employee"("email");

```

## Generate Prisma client

To generate the Prisma client, install the @prisma/client package using the following command:

```bash
pnpm add @prisma/client
pnpm prisma generate
```

### Integrating with Express

First, we add a start script in the package.json file.

```json
{
  "dependencies": {
    "@prisma/client": "^3.8.1",
    "@types/express": "^4.17.13",
    "@types/node": "^17.0.10",
    "express": "^4.17.2",
    "ts-node": "^10.4.0",
    "typescript": "^4.5.5"
  },
  "devDependencies": {
    "prisma": "^3.8.1"
  },
  "version": "0.0.0",
  "scripts":{
    "start": "nodemon index.ts"
  }
}

```

Next, create an index.ts file in the root directory. Then copy and paste the code below:

```typescript
import express, { Request, Response, Express } from 'express'

const app:Express = express()

const port:number = 3000

app.get('/', (req:Request, res:Response) => {
  res.send('Hello World!')
})

app.listen(port, ():void => {
  console.log(`Example app listening on port ${port} ðŸ”¥`)
})
```

```bash
pnpm start
```

## Import Prisma client

Next, we import the Prisma client, create some employee records, and send them as a response.

```typescript
import express, { Request, Response, Express } from "express";
import { Employee, PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

const app: Express = express();

const port: number = 3000;

app.get("/", async (req: Request, res: Response) => {
   
    try {

        await prisma.employee.create({
            data: {
              email: "alice@wondermail.com",
              name: "Alice Wonder"
            },
          });
        
          let foundEmployees: Employee[] = await prisma.employee.findMany();
        
          console.log(foundEmployees)
        
          res.send(foundEmployees); 
    } 
    
    catch (e) {
         console.log((e as Error).message)
    }

});

app.listen(port, (): void => {
  console.log(`Example app listening on port ${port} ðŸ”¥`);
});

```

## Advance Queries
### The $queryRaw method

This method allows us to write custom SQL queries. In the code given below, we first import the PrismaClient class from which the $queryRaw method is derived. We then make a simple SELECT SQL query to get all the employee records.

Since these custom SQL queries are simply strings, we can use the JavaScript template literals to add or input dynamic values or variables to our queries.

```ts
app.get("/", async (req: Request, res: Response) => {
  try {
   
    await prisma.$queryRaw`INSERT INTO "Employee" (email, name) VALUES ('xyz.ranjdom@mail.com', 'XYZ-NAME');`

    let allEmployee = await prisma.$queryRaw`SELECT * FROM "Employee"`
 

    res.send({
      data: allEmployee, 
      message: "Data fetched successfully"
      });
  } catch (e) {
    console.log((e as Error).message);
    res.status(501).send({
      message: (e as Error).message, 
      data: null})
  }
});
```

### The query method
The query method is provided by TypeORM repositories. With this method, we can write custom queries for a whole table, as shown below:

```ts
import { HttpStatus, Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import Record from 'src/entities/record';
import { IResponse } from 'src/global';
import { Repository } from 'typeorm';


@Injectable()
export class RecordService {
  constructor(
    @InjectRepository(Record) private _recordRepo: Repository<Record>,
  ) {}

  async getClassRank(): Promise<IResponse<Record[]>> {
    try {
      //query

      let foundClassRank = await this._recordRepo.query(`
            SELECT "studentId", "class", score as avs
            FROM record`);

      return {
        data: foundClassRank,
        status: true,
        statusCode: HttpStatus.OK,
        message: 'Class ranks successfully fetched',
      };
    } catch (e) {
      return {
        message: (e as Error).message,
        status: false,
        statusCode: HttpStatus.NOT_IMPLEMENTED,
      };
    }
  }
}
```

### The Raw method

The Raw method is imported from the typeorm library and allows us to write custom SQL queries on a particular table column. This appears similar to the query method. A slight difference, however, is that the Raw method works on the columns of the table on which the repository is defined, while query can take a full query on the table.

In the example below, weâ€™re querying the Wallet table for records that were created between a date range. Using these methods and the JavaScript template literal discussed earlier, we can easily use SQL query strings directly and insert dynamic variables as well.

```ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import * as moment from 'moment';
import { EWallet, Wallet } from 'src/entities/Wallet';
import { IRes } from 'src/interfaces/global';
import { Raw, Repository } from 'typeorm';
 
 
 export const EQueryLength = {
  WEEK: [7, 'd'],
  YEAR: [365, 'd'],
  MONTH: [30, 'd'],
}

 @Injectable()
export class TurboCartService {
  constructor(
    @InjectRepository(Wallet) private WalletRepo: Repository<Wallet>,
) {}

async getTotalPayout(): Promise<IRes<number>> {
    try {

      let start = moment().subtract(...EQueryLength[query]); // last 7/30 days

      let end = moment().add(1, 'd');

//      console.log(end.toDate(), start.toDate());

      let getVendorWallets: Wallet[] = await this.WalletRepo.find({
        where: {
          isPaid: true,
          wallet_type: EWallet.VENDOR,
          createdAt: Raw((alias) => `${alias} >= :start AND ${alias} < :end`, {
            end: new Date(end.toDate()),
            start: new Date(start.toDate()),
          }),
        },
      });

      // let getVendorWallets = await getConnection().createQueryBuilder().select("wallet").from(Wallet, "wallet").where('wallet.createdAt BETWEEN :start AND :end', { start: tomorrow.toString(), end : today.toString()}).getMany()

      console.log(getVendorWallets);
 

      return {
        message: 'Successfully fetched all payout(s)',
        status: true,
        data: total_balance,
      };
    } catch (e) {
      return {
        status: false,
        message: (e as Error).message,
      };
    }
  }
}
```

## Relationship

### One-to-one

A one-to-one relationship occurs when an entity is mapped to another entity uniquely, like when a record in a table maps to only one record in another table. A good example is a relationship between humans and their fingerprints.

In Prisma, we can achieve this with the @relation annotation. First, in the schema.prisma file, we define the model for fingerprints and humans as shown below. The model should include their unique IDs and other relevant information.

```typescript

// This is your Prisma schema file,
 
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Human {
  id Int @default(autoincrement()) @id
  email String
  name  String
}

model FingerPrint {
  id Int @default(autoincrement()) @id
  hash string @unique
}
```
Next, we use the @relation annotation to define the one-to-one relationship that exists between both models. We achieve this in SQL by mapping a column in one table to map the primary key of the other. Letâ€™s call this column in the FingerPrint schema humandId. This will map to the primary ID of the Human schema.

We can then update our schema, as seen below:

```typescript
// This is your Prisma schema file,
// ...

model Human {
  id Int @default(autoincrement()) @id
  email String
  name  String
  fingerPrint FingerPrint
}

model FingerPrint {
  id Int @default(autoincrement()) @id
  hash string @unique
  humanId Int
  human Human @relation(fields: [humanId], references: [id])
}

```

### One-to-many/Many-to-one

A one-to-many relationship maps an entity to several entities. Many-to-one relationships are defined similarly. As an example, consider the relationship between Earth (one) and humans (many).

One-to-many relationships are achieved in SQL by including the primary key of one table in the other table where itâ€™s referred to as the foreign key.

In Prisma, this is easily done, as shown below:

```typescript
// This is your Prisma schema file,
// ...
model Employee {
  id Int @default(autoincrement()) @id
  email String
  name  String
  company  Company? @relation(fields: [companyId], references: [id])
  companyId Int?
}

model Company {
  id Int @default(autoincrement()) @id
  company_email String @unique
  address String
  employee Employee[]
}

```

From this schema, Prisma then generates a table, as shown below:

```sql
CREATE TABLE "Employee" (
    id SERIAL PRIMARY KEY
    ...
);

CREATE TABLE "Company" (
    id SERIAL PRIMARY KEY,
    "companyId" integer NOT NULL,
    FOREIGN KEY ("companyId") REFERENCES "Employee"(id)
   ...
);

```

### The @relation annotation

In defining relationships in the Prisma schema, we always use the @relation annotation. This annotation takes a fields argument containing an array of columns of the table being defined that will serve as the foreign key. It also takes a references argument containing the primary key of the table whose model name appears before the @relation annotation.

### Many-to-many

A many-to-many relationship is one in which multiple entities in the database are associated with other multiple entities. A good example of this relationship is one between university courses and students. A student may take multiple courses, and a course may be taken by many different students.

In Prisma, this is achieved using a join table (also known as a pivot or link table).

Letâ€™s create a Student and Course model, as shown below:

```typescript
// ...
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

model Student {
  id      Int                  @id @default(autoincrement())
  name    String
  courses PivotStudentCourse[]
}

model Course {
  id       Int                  @id @default(autoincrement())
  name     String
  students PivotStudentCourse[]
}

//  pivot or join table goes here
model PivotStudentCourse {
  student    Student  @relation(fields: [studentId], references: [id])
  studentId  Int
  courses    Course   @relation(fields: [courseId], references: [id])
  courseId   Int
  assignedAt DateTime @default(now())

  @@id([studentId, courseId])
}

```

### Run a migration

```bash
pnpm prisma migrate dev --name "initial" --preview-feature
pnpm prisma generate
```

### Relation query

This section will develop a simple GET request that creates a company and also saves employees for the saved company. Remember that SQL is designed so that closely related information is tabularized uniquely and related by foreign keys that map one table to another.
Create
First, we create the company using sample data and then get the id of the created company. 


## Running a build for Prisma

Running a build is simply building the entire code to a set of executable files. This also includes compiling TypeScript to JavaScript. A common method of running a build is to compile all the TypeScript files to a JavaScript file and designate a single entry point for the app.

First, weâ€™ll need to update the tsconfig.json file at the root directory of our Prisma application. Weâ€™ll add the outDir key, which specifies the path and directory name of the compiled JavaScript code.

An example is shown below on line 11:

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2016",
    "sourceMap": true,
    "outDir": "./my-build-folder-name",
    "baseUrl": "./",
    "incremental": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

We can then run the command below to compile our TypeScript code to JavaScript:

```bash
tsc --project ./
```

#### Running a build for TypeORM

In TypeORM, we can easily run a build by running the script npm run build. This will create a dist folder, which is a compilation of our TypeScript files. We can then run the app with npm start or npm run start:debug to enable the debugger tool.
CI/CD

Git cloud services such as GitHub and Bitbucket are at the heart of developing robust CI/CD pipelines.

A basic CI/CD pipeline consists of three stages:

- [x] Development: The code or software is developed.

- [x] Integration: Cloud services, such as GitHub via git, manage different versions and patches of the uploaded code or software.
    Deployment/delivery: Webhooks from other cloud services are triggered to build the code if there are any changes. Also, at this stage, there may be another pipeline or scripts that can test the new code and ensure that there are no bugs or code breaks before theyâ€™re built on the server.

To achieve such a complex pipeline, other cloud services such as CircleCI, AWS, Azure, or Google Cloud Platform are integrated to manage several layers of this pipeline and ensure the whole process is fast and efficient.

---


`Good Question`
What does the "findUnique" Prisma method return if no record is found matching the criteria?
`Answer`
null

`Good Question`
While carrying out a read query for a related table or schema, what Prisma keyword is used to add the information from the related table in the results?
`Answer`
includes

`CRUD operation Ref.To:` 
[prisma-ex-company-ed](./prisma-ex-company-ed/README.md)
[prisma-ex-flightbooking-ed](./prisma-ex-flightbooking-ed/README.md)


