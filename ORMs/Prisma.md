# Prisma 

[prisma-ed](./prisma-ed/README.md)

---

Prisma is a popular and stable library with an active community contributing to building TypeScriptâ€™s back-end applications. Among the ORMs used in the industry, Prisma happens to be one of the best. It uses regular JavaScript objects and can interact with any SQL database.

```ts
// create employee
const new_employee = await prisma.employee.create({
  data: {
    employee_name: 'Alice',
    employee_email: 'alice@prisma.io',
  },
})
```

## Features of Prisma
### Models

Prisma has a very unique structure. It provides a model that enables a well-outlined structure, defining how our database columns interact with each other.

```ts
//schema.prisma

datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"  
}

model Employee {

  id Int @default(autoincrement()) @id
  email String  @unique
  name  String?
}

```

#### There are two major, supported field types:

- [x] Scalar: Scalar data types are the regular data types (for example, String and Int.)
- [x] Model: A field can have a model as a field type, and this is used to define relationships.

A key part of the Prisma schema is the model. The model maps to the table created in the database, similarly to how we defined Employee above. The parts of this model are called fields.

The Prisma schema also introduces attributes. These attributes map the column value to the native database data type. A few of these are:

- [x] @unique: Used to declare a column value as unique.
- [x] @default: Used to set a default value for the column.
- [x] @VarChar(x): Used to declare a character length for the column with x representing the character length.
- [x] @id: Sets the column as the primary id column for that given model or table.

### API Interface

Another important feature is the **Prisma client, which provides an interface for communicating with the database and carrying out queries.**

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// create employee
const new_employee = await prisma.employee.create({
  data: {
    employee_name: 'Alice',
    employee_email: 'alice@prisma.io',
  },
})

// fetch-query:::get all employees 
const employees = await prisma.employee.findMany()
```

Among other TypeScript ORMs, Prisma has a unique feature that automatically writes migration and generates type-safe code. Prisma currently supports MongoDB (preview), SQL Server, MySQL, PostgreSQL, and SQLite.

---

`Good Question`
If a connection error occurs due to the Prisma client not being able to interface with the database (for example, while performing write operation), which of the following might be a cause?
`Answer`
- [x] Database permissions were not granted.
- [x] The schema structure does not match the database tables.
- [x] The table data thatâ€™s been queried may not exist.

## Prisma Setup

```bash
mkdir educative-prisma && cd educative-prisma \
pnpm init -y \
git init \
pnpm add typescript ts-node @types/node express @types/express
touch tsconfig.json
```

```json
 {
   "compilerOptions": {
      "strict": true,
      "sourceMap": true,
      "outDir": "dist",
      "esModuleInterop": true,
      "lib": ["esnext"]
      }
 }
```

```bash
pnpm add prisma --dev \
touch docker-compose.yml
```

```yaml
version: '3.8'
services:
  postgres:
    image: postgres
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=company_db
    ports:
      - '5432:5432'
    expose:
      - 5432
volumes:
  postgres:
```

```bash
docker-compose up -d
```

```bash
pnpm prisma init
```

In the file schema.prisma, weâ€™ll define our model that will be used to generate queries used to create the SQL tables. Letâ€™s create a simple employee model:

```ts
//schema.prisma

datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"  
}

model employee {

  id Int @default(autoincrement()) @id
  email String  @unique
  name  String?

}
```

```bash
touch .env .gitignore
```

Add the code below to the .env file:

```bash
DATABASE_URL=postgresql://postgres:password@localhost:5432/company_db?schema=public
```

Add the code below to the .gitignore file:

```md
.env

node_modules/ 
```

â€‹â€‹Next, we run a migration to generate the corresponding SQL tables using the following command:

```bash
pnpm prisma migrate dev --name "initial" --preview-feature
```

This command creates a prisma/migrations folder and a migration.sql file in it where we should be able to view the SQL queries generated by Prisma from our model.

The file content should be similar to the one below:


```sql
-- CreateTable
CREATE TABLE "employee" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "employee_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "employee_email_key" ON "employee"("email");

```

## Generate Prisma client

To generate the Prisma client, install the @prisma/client package using the following command:

```bash
pnpm add @prisma/client
pnpm prisma generate
```

### Integrating with Express

First, we add a start script in the package.json file.

```json
{
  "dependencies": {
    "@prisma/client": "^3.8.1",
    "@types/express": "^4.17.13",
    "@types/node": "^17.0.10",
    "express": "^4.17.2",
    "ts-node": "^10.4.0",
    "typescript": "^4.5.5"
  },
  "devDependencies": {
    "prisma": "^3.8.1"
  },
  "version": "0.0.0",
  "scripts":{
    "start": "nodemon index.ts"
  }
}

```

Next, create an index.ts file in the root directory. Then copy and paste the code below:

```ts
import express, { Request, Response, Express } from 'express'

const app:Express = express()

const port:number = 3000

app.get('/', (req:Request, res:Response) => {
  res.send('Hello World!')
})

app.listen(port, ():void => {
  console.log(`Example app listening on port ${port} ðŸ”¥`)
})
```

```bash
pnpm start
```

## Import Prisma client

Next, we import the Prisma client, create some employee records, and send them as a response.

```ts
import express, { Request, Response, Express } from "express";
import { Employee, PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

const app: Express = express();

const port: number = 3000;

app.get("/", async (req: Request, res: Response) => {
   
    try {

        await prisma.employee.create({
            data: {
              email: "alice@wondermail.com",
              name: "Alice Wonder"
            },
          });
        
          let foundEmployees: Employee[] = await prisma.employee.findMany();
        
          console.log(foundEmployees)
        
          res.send(foundEmployees); 
    } 
    
    catch (e) {
         console.log((e as Error).message)
    }

});

app.listen(port, (): void => {
  console.log(`Example app listening on port ${port} ðŸ”¥`);
});

```

## Relationship

### One-to-one

A one-to-one relationship occurs when an entity is mapped to another entity uniquely, like when a record in a table maps to only one record in another table. A good example is a relationship between humans and their fingerprints.

In Prisma, we can achieve this with the @relation annotation. First, in the schema.prisma file, we define the model for fingerprints and humans as shown below. The model should include their unique IDs and other relevant information.

```ts

// This is your Prisma schema file,
 
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Human {
  id Int @default(autoincrement()) @id
  email String
  name  String
}

model FingerPrint {
  id Int @default(autoincrement()) @id
  hash string @unique
}
```
Next, we use the @relation annotation to define the one-to-one relationship that exists between both models. We achieve this in SQL by mapping a column in one table to map the primary key of the other. Letâ€™s call this column in the FingerPrint schema humandId. This will map to the primary ID of the Human schema.

We can then update our schema, as seen below:

```ts
// This is your Prisma schema file,
// ...

model Human {
  id Int @default(autoincrement()) @id
  email String
  name  String
  fingerPrint FingerPrint
}

model FingerPrint {
  id Int @default(autoincrement()) @id
  hash string @unique
  humanId Int
  human Human @relation(fields: [humanId], references: [id])
}

```

### One-to-many/Many-to-one

A one-to-many relationship maps an entity to several entities. Many-to-one relationships are defined similarly. As an example, consider the relationship between Earth (one) and humans (many).

One-to-many relationships are achieved in SQL by including the primary key of one table in the other table where itâ€™s referred to as the foreign key.

In Prisma, this is easily done, as shown below:

```ts
// This is your Prisma schema file,
// ...
model Employee {
  id Int @default(autoincrement()) @id
  email String
  name  String
  company  Company? @relation(fields: [companyId], references: [id])
  companyId Int?
}

model Company {
  id Int @default(autoincrement()) @id
  company_email String @unique
  address String
  employee Employee[]
}

```

From this schema, Prisma then generates a table, as shown below:

```sql
CREATE TABLE "Employee" (
    id SERIAL PRIMARY KEY
    ...
);

CREATE TABLE "Company" (
    id SERIAL PRIMARY KEY,
    "companyId" integer NOT NULL,
    FOREIGN KEY ("companyId") REFERENCES "Employee"(id)
   ...
);

```

### The @relation annotation

In defining relationships in the Prisma schema, we always use the @relation annotation. This annotation takes a fields argument containing an array of columns of the table being defined that will serve as the foreign key. It also takes a references argument containing the primary key of the table whose model name appears before the @relation annotation.

### Many-to-many

A many-to-many relationship is one in which multiple entities in the database are associated with other multiple entities. A good example of this relationship is one between university courses and students. A student may take multiple courses, and a course may be taken by many different students.

In Prisma, this is achieved using a join table (also known as a pivot or link table).

Letâ€™s create a Student and Course model, as shown below:

```ts
// ...
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

model Student {
  id      Int                  @id @default(autoincrement())
  name    String
  courses PivotStudentCourse[]
}

model Course {
  id       Int                  @id @default(autoincrement())
  name     String
  students PivotStudentCourse[]
}

//  pivot or join table goes here
model PivotStudentCourse {
  student    Student  @relation(fields: [studentId], references: [id])
  studentId  Int
  courses    Course   @relation(fields: [courseId], references: [id])
  courseId   Int
  assignedAt DateTime @default(now())

  @@id([studentId, courseId])
}

```

### Run a migration

```bash
pnpm prisma migrate dev --name "initial" --preview-feature
pnpm prisma generate
```

### Relation query

This section will develop a simple GET request that creates a company and also saves employees for the saved company. Remember that SQL is designed so that closely related information is tabularized uniquely and related by foreign keys that map one table to another.
Create
First, we create the company using sample data and then get the id of the created company. 


---


`Good Question`
What does the "findUnique" Prisma method return if no record is found matching the criteria?
`Answer`
null

`Good Question`
While carrying out a read query for a related table or schema, what Prisma keyword is used to add the information from the related table in the results?
`Answer`
includes

`CRUD operation Ref.To:` [prisma-ed](./prisma-ed/README.md)


